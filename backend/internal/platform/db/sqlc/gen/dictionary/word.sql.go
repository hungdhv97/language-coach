// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: word.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchWords = `-- name: CountSearchWords :one
SELECT COUNT(DISTINCT w.id)
FROM words w
WHERE w.language_id = $1
  AND (
    w.lemma ILIKE $2
    OR w.lemma_normalized ILIKE $2
    OR w.search_key ILIKE $2
  )
`

type CountSearchWordsParams struct {
	LanguageID    int16  `json:"language_id"`
	SearchPattern string `json:"search_pattern"`
}

func (q *Queries) CountSearchWords(ctx context.Context, arg CountSearchWordsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchWords, arg.LanguageID, arg.SearchPattern)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findTranslationsForWord = `-- name: FindTranslationsForWord :many
SELECT DISTINCT tw.id, tw.language_id, tw.lemma, tw.lemma_normalized, tw.search_key,
       tw.romanization, tw.script_code, tw.frequency_rank,
       tw.note, tw.created_at, tw.updated_at
FROM words sw
INNER JOIN senses s ON sw.id = s.word_id
INNER JOIN sense_translations st ON s.id = st.source_sense_id
INNER JOIN words tw ON st.target_word_id = tw.id
WHERE sw.id = $1
  AND tw.language_id = $2
ORDER BY st.priority, tw.frequency_rank NULLS LAST, tw.id
LIMIT $3
`

type FindTranslationsForWordParams struct {
	SourceWordID     int64 `json:"source_word_id"`
	TargetLanguageID int16 `json:"target_language_id"`
	Limit            int32 `json:"limit"`
}

func (q *Queries) FindTranslationsForWord(ctx context.Context, arg FindTranslationsForWordParams) ([]Word, error) {
	rows, err := q.db.Query(ctx, findTranslationsForWord, arg.SourceWordID, arg.TargetLanguageID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWordByID = `-- name: FindWordByID :one
SELECT id, language_id, lemma, lemma_normalized, search_key,
       romanization, script_code, frequency_rank,
       note, created_at, updated_at
FROM words
WHERE id = $1
`

func (q *Queries) FindWordByID(ctx context.Context, id int64) (Word, error) {
	row := q.db.QueryRow(ctx, findWordByID, id)
	var i Word
	err := row.Scan(
		&i.ID,
		&i.LanguageID,
		&i.Lemma,
		&i.LemmaNormalized,
		&i.SearchKey,
		&i.Romanization,
		&i.ScriptCode,
		&i.FrequencyRank,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findWordsByIDs = `-- name: FindWordsByIDs :many
SELECT id, language_id, lemma, lemma_normalized, search_key,
       romanization, script_code, frequency_rank,
       note, created_at, updated_at
FROM words
WHERE id = ANY($1::bigint[])
ORDER BY id
`

func (q *Queries) FindWordsByIDs(ctx context.Context, dollar_1 []int64) ([]Word, error) {
	rows, err := q.db.Query(ctx, findWordsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWordsByLevelAndLanguages = `-- name: FindWordsByLevelAndLanguages :many
SELECT DISTINCT w.id, w.language_id, w.lemma, w.lemma_normalized, w.search_key,
       w.romanization, w.script_code, w.frequency_rank,
       w.note, w.created_at, w.updated_at
FROM words w
INNER JOIN senses s ON w.id = s.word_id
WHERE s.level_id = $1
  AND w.language_id = $2
  AND EXISTS (
      SELECT 1
      FROM sense_translations st
      INNER JOIN words tw ON st.target_word_id = tw.id
      WHERE st.source_sense_id = s.id
        AND tw.language_id = $3
  )
ORDER BY w.frequency_rank NULLS LAST, w.id
LIMIT $4
`

type FindWordsByLevelAndLanguagesParams struct {
	LevelID          pgtype.Int8 `json:"level_id"`
	SourceLanguageID int16       `json:"source_language_id"`
	TargetLanguageID int16       `json:"target_language_id"`
	Limit            int32       `json:"limit"`
}

func (q *Queries) FindWordsByLevelAndLanguages(ctx context.Context, arg FindWordsByLevelAndLanguagesParams) ([]Word, error) {
	rows, err := q.db.Query(ctx, findWordsByLevelAndLanguages,
		arg.LevelID,
		arg.SourceLanguageID,
		arg.TargetLanguageID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWordsByLevelAndTopicsAndLanguages = `-- name: FindWordsByLevelAndTopicsAndLanguages :many
SELECT DISTINCT w.id, w.language_id, w.lemma, w.lemma_normalized, w.search_key,
       w.romanization, w.script_code, w.frequency_rank,
       w.note, w.created_at, w.updated_at
FROM words w
INNER JOIN senses s ON w.id = s.word_id
WHERE s.level_id = $1
  AND w.language_id = $2
  AND (
    -- If topic_ids array is empty/null, include all words
    -- Otherwise filter by topic_ids using ANY
    $3::bigint[] IS NULL
    OR array_length($3::bigint[], 1) IS NULL
    OR EXISTS (
      SELECT 1
      FROM word_topics wt
      WHERE wt.word_id = w.id
        AND wt.topic_id = ANY($3::bigint[])
    )
  )
  AND EXISTS (
      SELECT 1
      FROM sense_translations st
      INNER JOIN words tw ON st.target_word_id = tw.id
      WHERE st.source_sense_id = s.id
        AND tw.language_id = $4
  )
ORDER BY w.frequency_rank NULLS LAST, w.id
LIMIT $5
`

type FindWordsByLevelAndTopicsAndLanguagesParams struct {
	LevelID          pgtype.Int8 `json:"level_id"`
	SourceLanguageID int16       `json:"source_language_id"`
	TopicIds         []int64     `json:"topic_ids"`
	TargetLanguageID int16       `json:"target_language_id"`
	Limit            int32       `json:"limit"`
}

func (q *Queries) FindWordsByLevelAndTopicsAndLanguages(ctx context.Context, arg FindWordsByLevelAndTopicsAndLanguagesParams) ([]Word, error) {
	rows, err := q.db.Query(ctx, findWordsByLevelAndTopicsAndLanguages,
		arg.LevelID,
		arg.SourceLanguageID,
		arg.TopicIds,
		arg.TargetLanguageID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWordsByTopicAndLanguages = `-- name: FindWordsByTopicAndLanguages :many
SELECT DISTINCT w.id, w.language_id, w.lemma, w.lemma_normalized, w.search_key,
       w.romanization, w.script_code, w.frequency_rank,
       w.note, w.created_at, w.updated_at
FROM words w
INNER JOIN word_topics wt ON w.id = wt.word_id
WHERE wt.topic_id = $1
  AND w.language_id = $2
  AND EXISTS (
      SELECT 1
      FROM senses s
      INNER JOIN sense_translations st ON s.id = st.source_sense_id
      INNER JOIN words tw ON st.target_word_id = tw.id
      WHERE s.word_id = w.id
        AND tw.language_id = $3
  )
ORDER BY w.frequency_rank NULLS LAST, w.id
LIMIT $4
`

type FindWordsByTopicAndLanguagesParams struct {
	TopicID          int64 `json:"topic_id"`
	SourceLanguageID int16 `json:"source_language_id"`
	TargetLanguageID int16 `json:"target_language_id"`
	Limit            int32 `json:"limit"`
}

func (q *Queries) FindWordsByTopicAndLanguages(ctx context.Context, arg FindWordsByTopicAndLanguagesParams) ([]Word, error) {
	rows, err := q.db.Query(ctx, findWordsByTopicAndLanguages,
		arg.TopicID,
		arg.SourceLanguageID,
		arg.TargetLanguageID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchWords = `-- name: SearchWords :many
SELECT w.id, w.language_id, w.lemma, w.lemma_normalized, w.search_key,
       w.romanization, w.script_code, w.frequency_rank,
       w.note, w.created_at, w.updated_at
FROM words w
WHERE w.language_id = $1
  AND (
    w.lemma ILIKE $2
    OR w.lemma_normalized ILIKE $2
    OR w.search_key ILIKE $2
  )
ORDER BY 
  CASE 
    WHEN w.lemma = $3 THEN 1
    WHEN w.lemma ILIKE $2 THEN 2
    WHEN w.lemma_normalized ILIKE $2 THEN 3
    WHEN w.search_key ILIKE $2 THEN 4
    ELSE 5
  END,
  w.frequency_rank NULLS LAST,
  w.id
LIMIT $5 OFFSET $4
`

type SearchWordsParams struct {
	LanguageID    int16  `json:"language_id"`
	SearchPattern string `json:"search_pattern"`
	ExactMatch    string `json:"exact_match"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) SearchWords(ctx context.Context, arg SearchWordsParams) ([]Word, error) {
	rows, err := q.db.Query(ctx, searchWords,
		arg.LanguageID,
		arg.SearchPattern,
		arg.ExactMatch,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Word{}
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.LanguageID,
			&i.Lemma,
			&i.LemmaNormalized,
			&i.SearchKey,
			&i.Romanization,
			&i.ScriptCode,
			&i.FrequencyRank,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

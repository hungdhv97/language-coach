// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: answer.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGameAnswer = `-- name: CreateGameAnswer :one
INSERT INTO vocab_game_question_answers (
    question_id, session_id, user_id,
    selected_option_id, is_correct, response_time_ms, answered_at
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, answered_at
`

type CreateGameAnswerParams struct {
	QuestionID       int64            `json:"question_id"`
	SessionID        int64            `json:"session_id"`
	UserID           int64            `json:"user_id"`
	SelectedOptionID pgtype.Int8      `json:"selected_option_id"`
	IsCorrect        bool             `json:"is_correct"`
	ResponseTimeMs   pgtype.Int4      `json:"response_time_ms"`
	AnsweredAt       pgtype.Timestamp `json:"answered_at"`
}

type CreateGameAnswerRow struct {
	ID         int64            `json:"id"`
	AnsweredAt pgtype.Timestamp `json:"answered_at"`
}

func (q *Queries) CreateGameAnswer(ctx context.Context, arg CreateGameAnswerParams) (CreateGameAnswerRow, error) {
	row := q.db.QueryRow(ctx, createGameAnswer,
		arg.QuestionID,
		arg.SessionID,
		arg.UserID,
		arg.SelectedOptionID,
		arg.IsCorrect,
		arg.ResponseTimeMs,
		arg.AnsweredAt,
	)
	var i CreateGameAnswerRow
	err := row.Scan(&i.ID, &i.AnsweredAt)
	return i, err
}

const findGameAnswerByQuestionID = `-- name: FindGameAnswerByQuestionID :one
SELECT id, question_id, session_id, user_id,
       selected_option_id, is_correct, response_time_ms, answered_at
FROM vocab_game_question_answers
WHERE question_id = $1 AND session_id = $2 AND user_id = $3
LIMIT 1
`

type FindGameAnswerByQuestionIDParams struct {
	QuestionID int64 `json:"question_id"`
	SessionID  int64 `json:"session_id"`
	UserID     int64 `json:"user_id"`
}

func (q *Queries) FindGameAnswerByQuestionID(ctx context.Context, arg FindGameAnswerByQuestionIDParams) (VocabGameQuestionAnswer, error) {
	row := q.db.QueryRow(ctx, findGameAnswerByQuestionID, arg.QuestionID, arg.SessionID, arg.UserID)
	var i VocabGameQuestionAnswer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SessionID,
		&i.UserID,
		&i.SelectedOptionID,
		&i.IsCorrect,
		&i.ResponseTimeMs,
		&i.AnsweredAt,
	)
	return i, err
}

const findGameAnswersBySessionID = `-- name: FindGameAnswersBySessionID :many
SELECT id, question_id, session_id, user_id,
       selected_option_id, is_correct, response_time_ms, answered_at
FROM vocab_game_question_answers
WHERE session_id = $1 AND user_id = $2
ORDER BY answered_at
`

type FindGameAnswersBySessionIDParams struct {
	SessionID int64 `json:"session_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) FindGameAnswersBySessionID(ctx context.Context, arg FindGameAnswersBySessionIDParams) ([]VocabGameQuestionAnswer, error) {
	rows, err := q.db.Query(ctx, findGameAnswersBySessionID, arg.SessionID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabGameQuestionAnswer{}
	for rows.Next() {
		var i VocabGameQuestionAnswer
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.SessionID,
			&i.UserID,
			&i.SelectedOptionID,
			&i.IsCorrect,
			&i.ResponseTimeMs,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: question.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGameQuestion = `-- name: CreateGameQuestion :one
INSERT INTO vocab_game_questions (
    session_id, question_order, question_type,
    source_word_id, source_sense_id, correct_target_word_id,
    source_language_id, target_language_id, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at
`

type CreateGameQuestionParams struct {
	SessionID           int64            `json:"session_id"`
	QuestionOrder       int16            `json:"question_order"`
	QuestionType        string           `json:"question_type"`
	SourceWordID        int64            `json:"source_word_id"`
	SourceSenseID       pgtype.Int8      `json:"source_sense_id"`
	CorrectTargetWordID int64            `json:"correct_target_word_id"`
	SourceLanguageID    int16            `json:"source_language_id"`
	TargetLanguageID    int16            `json:"target_language_id"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
}

type CreateGameQuestionRow struct {
	ID        int64            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateGameQuestion(ctx context.Context, arg CreateGameQuestionParams) (CreateGameQuestionRow, error) {
	row := q.db.QueryRow(ctx, createGameQuestion,
		arg.SessionID,
		arg.QuestionOrder,
		arg.QuestionType,
		arg.SourceWordID,
		arg.SourceSenseID,
		arg.CorrectTargetWordID,
		arg.SourceLanguageID,
		arg.TargetLanguageID,
		arg.CreatedAt,
	)
	var i CreateGameQuestionRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createGameQuestionOption = `-- name: CreateGameQuestionOption :one
INSERT INTO vocab_game_question_options (
    question_id, option_label, target_word_id, is_correct
) VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateGameQuestionOptionParams struct {
	QuestionID   int64  `json:"question_id"`
	OptionLabel  string `json:"option_label"`
	TargetWordID int64  `json:"target_word_id"`
	IsCorrect    bool   `json:"is_correct"`
}

func (q *Queries) CreateGameQuestionOption(ctx context.Context, arg CreateGameQuestionOptionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createGameQuestionOption,
		arg.QuestionID,
		arg.OptionLabel,
		arg.TargetWordID,
		arg.IsCorrect,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findGameQuestionByID = `-- name: FindGameQuestionByID :one
SELECT id, session_id, question_order, question_type,
       source_word_id, source_sense_id, correct_target_word_id,
       source_language_id, target_language_id, created_at
FROM vocab_game_questions
WHERE id = $1
`

func (q *Queries) FindGameQuestionByID(ctx context.Context, id int64) (VocabGameQuestion, error) {
	row := q.db.QueryRow(ctx, findGameQuestionByID, id)
	var i VocabGameQuestion
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.QuestionOrder,
		&i.QuestionType,
		&i.SourceWordID,
		&i.SourceSenseID,
		&i.CorrectTargetWordID,
		&i.SourceLanguageID,
		&i.TargetLanguageID,
		&i.CreatedAt,
	)
	return i, err
}

const findGameQuestionOptionsByQuestionID = `-- name: FindGameQuestionOptionsByQuestionID :many
SELECT id, question_id, option_label, target_word_id, is_correct
FROM vocab_game_question_options
WHERE question_id = $1
ORDER BY option_label
`

func (q *Queries) FindGameQuestionOptionsByQuestionID(ctx context.Context, questionID int64) ([]VocabGameQuestionOption, error) {
	rows, err := q.db.Query(ctx, findGameQuestionOptionsByQuestionID, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabGameQuestionOption{}
	for rows.Next() {
		var i VocabGameQuestionOption
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.OptionLabel,
			&i.TargetWordID,
			&i.IsCorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGameQuestionOptionsByQuestionIDs = `-- name: FindGameQuestionOptionsByQuestionIDs :many
SELECT id, question_id, option_label, target_word_id, is_correct
FROM vocab_game_question_options
WHERE question_id = ANY($1::bigint[])
ORDER BY question_id, option_label
`

func (q *Queries) FindGameQuestionOptionsByQuestionIDs(ctx context.Context, dollar_1 []int64) ([]VocabGameQuestionOption, error) {
	rows, err := q.db.Query(ctx, findGameQuestionOptionsByQuestionIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabGameQuestionOption{}
	for rows.Next() {
		var i VocabGameQuestionOption
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.OptionLabel,
			&i.TargetWordID,
			&i.IsCorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGameQuestionsBySessionID = `-- name: FindGameQuestionsBySessionID :many
SELECT id, session_id, question_order, question_type,
       source_word_id, source_sense_id, correct_target_word_id,
       source_language_id, target_language_id, created_at
FROM vocab_game_questions
WHERE session_id = $1
ORDER BY question_order
`

func (q *Queries) FindGameQuestionsBySessionID(ctx context.Context, sessionID int64) ([]VocabGameQuestion, error) {
	rows, err := q.db.Query(ctx, findGameQuestionsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabGameQuestion{}
	for rows.Next() {
		var i VocabGameQuestion
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.QuestionOrder,
			&i.QuestionType,
			&i.SourceWordID,
			&i.SourceSenseID,
			&i.CorrectTargetWordID,
			&i.SourceLanguageID,
			&i.TargetLanguageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
